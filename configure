#!/usr/bin/python

lib_srcs = [
        'wire', 'wire_fd', 'wire_timeout', 'wire_net', 'wire_pool', 'wire_stack', 'wire_io', 'wire_log', 'http_parser', 'wire_channel', 'wire_wait', 'wire_lock', 'wire_semaphore', 'coro'
]

test_srcs = {
        'base': ('base',),
        'echo_server': ('echo_server', 'utils'),
        'recurser': ('recurser',),
        'web': ('web', 'utils'),
        'channel': ('channel',),
        'waiters': ('waiters',),
        'bench': ('bench',),
        'locks': ('locks',),
        'asyncio': ('asyncio',),
        'pool': ('pool',),
        'wait': ('wait',),
        'web_client': ('web_client', 'utils'),
        'log_stdout': ('log_stdout', ),
}

cflags = ['-Iinclude', '-g', '-O0', '-Wall', '-Werror', '-Wextra', '-Wshadow',
          '-Wmissing-prototypes', '-Winit-self', '-pipe', '-DCORO_STACKALLOC=0', '-D_GNU_SOURCE',
          '-D_FORTIFY_SOURCE=2']
ldflags = ['-lrt', '-lpthread']

import os, os.path
import glob
import ninja_syntax

if os.path.exists('/usr/include/valgrind/valgrind.h'):
        cflags += ['-I/usr/include/valgrind', '-DUSE_VALGRIND']

n = ninja_syntax.Writer(file('build.ninja', 'w'))
n.comment('Auto generated by ./configure, edit the configure script instead')
n.newline()

env_keys = set(['CC', 'AR', 'CFLAGS', 'LDFLAGS'])
configure_env = dict((k, os.environ[k]) for k in os.environ if k in env_keys)
if configure_env:
    config_str = ' '.join([k+'='+configure_env[k] for k in configure_env])
    n.variable('configure_env', config_str+'$ ')
n.newline()

CC = configure_env.get('CC', 'gcc')
n.variable('cc', CC)
AR = configure_env.get('AR', 'ar')
n.variable('ar', AR)
n.newline()

def shell_escape(str):
        """Escape str such that it's interpreted as a single argument by
           the shell."""

        # This isn't complete, but it's just enough to make NINJA_PYTHON work.
        if '"' in str:
                return "'%s'" % str.replace("'", "\\'")
        return str

if 'CFLAGS' in configure_env:
    cflags.append(configure_env['CFLAGS'])
n.variable('cflags', ' '.join(shell_escape(flag) for flag in cflags))

if 'LDFLAGS' in configure_env:
    ldflags.append(configure_env['LDFLAGS'])
n.variable('ldflags', ' '.join(shell_escape(flag) for flag in ldflags))

n.newline()

n.rule('c',
        command='$cc -MMD -MT $out -MF $out.d $cflags $extracflags -c $in -o $out',
        depfile='$out.d',
        deps='gcc',
        description='CC $out'
)
n.newline()

n.rule('ar',
        command='rm -f $out && $ar crs $out $in',
        description='AR $out',
)
n.newline()

n.rule('link',
        command='$cc -o $out $in $libs $ldflags',
        description='LINK $out'
)
n.newline()

n.rule('gen_wire_io',
        command='tools/gen_wire_io.py $type > $out',
        description='GEN_WIRE_IO $out')
n.newline()

n.rule('ct_gen',
        command='test/ct/gen $in > $out',
        description='CT_GEN %out')
n.newline()

def src(filename):
        return os.path.join('src', filename)
def btest(filename):
        return os.path.join('test', filename)
def built(filename):
        return os.path.join('built', filename)
def cc(filename, src, **kwargs):
        if filename.endswith('.c'):
                return n.build(built(filename)[:-2] + '.o', 'c', filename, **kwargs)
        else:
                return n.build(built(src(filename)) + '.o', 'c', src(filename) + '.c', **kwargs)

all_targets = []

lib_objs = []
for source in lib_srcs:
        lib_objs += cc(source, src)
lib = n.build('libwire.a', 'ar', lib_objs)
all_targets += lib
n.newline()

test_exec = []
test_objs = {}
for test in test_srcs.keys():
        objs = []
        for source in test_srcs[test]:
                if source in test_objs.keys():
                        objs += test_objs[source]
                else:
                        obj = cc(source, btest)
                        test_objs[source] = obj
                        objs += obj
        test_exec += n.build(test, 'link', objs, implicit=lib, variables=[('libs', lib)])
        all_targets += test_exec
n.newline()

test_objs = []
for fname in glob.glob('test/ct_*.c'):
    test_objs += cc(fname, src, variables=[('extracflags', '-Wno-missing-prototypes')])
ct_gen_src = n.build('test/ct/ct_gen.c', 'ct_gen', test_objs, implicit=['test/ct/gen'])
test_objs += cc('ct/ct_gen', btest)
test_objs += cc('ct/ct', btest, variables=[('cflags', '')])
test_exec += n.build('ct', 'link', test_objs, variables=[('libs', lib)], implicit=lib)
all_targets += test_exec
n.newline()

n.rule('configure',
        command='${configure_env} ./configure',
        description='CONFIGURE build.ninja',
        generator=True
        )
all_targets += n.build('build.ninja', 'configure', implicit='./configure')
n.newline()

n.rule('tags',
        command='ctags $in',
        description='CTAGS $out'
        )
all_targets += n.build('tags', 'tags', [src(name) + '.c' for name in lib_srcs] + glob.glob('include/*.h'))
n.newline()

n.comment('Create doxygen docs, requires explicit build: ninja doxygen')
n.rule('doxygen',
        command='doxygen $in',
        description='DOXYGEN $in')
n.build('doxygen', 'doxygen', 'doxygen.config')
n.newline()

n.build('all', 'phony', all_targets)
n.default('all')

print 'Configure done'
